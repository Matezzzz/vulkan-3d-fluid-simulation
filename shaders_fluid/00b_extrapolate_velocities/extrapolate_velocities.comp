#version 450

layout(local_size_x = 10, local_size_y = 10, local_size_z = 1) in;

layout(set = 0, binding = 0, r8ui) uniform restrict readonly uimage3D new_cell_types;
layout(set = 0, binding = 1, r8ui) uniform restrict readonly uimage3D cell_types;
layout(set = 0, binding = 2, rgba32f) uniform restrict image3D velocities;

const uint CELL_INACTIVE = 0;
const uint CELL_AIR = 1;
const uint CELL_WATER = 2;
const uint CELL_SOLID = 3;


bool isNewWaterAt(ivec3 pos){
    return (imageLoad(new_cell_types, pos).x == CELL_WATER);
}

uint cellAt(ivec3 pos){
    return imageLoad(cell_types, pos).x;
}

uint newCellAt(ivec3 pos){
    return imageLoad(new_cell_types, pos).x;
}

bool isWater(uint a){
    return (a == CELL_WATER);
}
bool isActive(uint a){
    return (a != CELL_INACTIVE);
}

vec3 getExtrapolatedVelocity(ivec3 i){
    int c = 0;
    vec4 v = vec4(0, 0, 0, 0);

    if (imageLoad(cell_types, i - ivec3(1, 0, 0)).x == CELL_WATER){ v += imageLoad(velocities, i - ivec3(1, 0, 0)); c++; }
    if (imageLoad(cell_types, i - ivec3(0, 1, 0)).x == CELL_WATER){ v += imageLoad(velocities, i - ivec3(0, 1, 0)); c++; }
    if (imageLoad(cell_types, i - ivec3(0, 0, 1)).x == CELL_WATER){ v += imageLoad(velocities, i - ivec3(0, 0, 1)); c++; }
    if (imageLoad(cell_types, i + ivec3(1, 0, 0)).x == CELL_WATER){ v += imageLoad(velocities, i + ivec3(1, 0, 0)); c++; }
    if (imageLoad(cell_types, i + ivec3(0, 1, 0)).x == CELL_WATER){ v += imageLoad(velocities, i + ivec3(0, 1, 0)); c++; }
    if (imageLoad(cell_types, i + ivec3(0, 0, 1)).x == CELL_WATER){ v += imageLoad(velocities, i + ivec3(0, 0, 1)); c++; }
    if (c != 0) return v.xyz / c;
    return vec3(0, 0, 0);
}


const int VELOCITY_DO_NOTHING = 0;
const int VELOCITY_RESET = 1;
const int VELOCITY_EXTRAPOLATE = 2;
int getNewVelocityState(bool was_active, bool is_active, ivec3 i){
    if (was_active || isActive(cellAt(i - ivec3(1, 0, 0)))){
        if (is_active || isActive(newCellAt(i - ivec3(1, 0, 0)))){
            return VELOCITY_DO_NOTHING;
        }else{
            return VELOCITY_RESET;
        }
    }else{
        if (is_active || isActive(newCellAt(i - ivec3(1, 0, 0)))){
            return VELOCITY_EXTRAPOLATE;
        }else{
            return VELOCITY_DO_NOTHING;
        }
    }
}

float getNewVelocityComponent(vec3 extrapolated_velocity, bool was_active, bool is_active, ivec3 i, int comp){
    ivec3 move = ivec3(0, 0, 0);
    move[comp] = -1;
    
    int vel_state = getNewVelocityState(was_active, is_active, i + move);
    if (vel_state == VELOCITY_RESET){
        return 0;
    }else if (vel_state == VELOCITY_EXTRAPOLATE){
        return extrapolated_velocity[comp];
    }
}

vec3 getNewVelocity(ivec3 i){
    bool local_was_active = isActive(cellAt(i));
    bool local_is_active = isActive(cellAt(i));

    vec3 extrapolated_vel = getExtrapolatedVelocity(i);

    return vec3(
        getNewVelocityComponent(extrapolated_vel, local_was_active, local_is_active, i, 0),
        getNewVelocityComponent(extrapolated_vel, local_was_active, local_is_active, i, 1),
        getNewVelocityComponent(extrapolated_vel, local_was_active, local_is_active, i, 2)
    );
}

void main(){
    ivec3 i = ivec3(gl_GlobalInvocationID.xyz);
    imageStore(velocities, i, vec4(getNewVelocity(i), 0.0));        
}

