#version 450

layout(local_size_x = 10, local_size_y = 10, local_size_z = 1) in;

layout(set = 0, binding = 0, r8ui) uniform restrict readonly uimage3D new_cell_types;
layout(set = 0, binding = 1, r8ui) uniform restrict readonly uimage3D cell_types;
layout(set = 0, binding = 2, rgba32f) uniform restrict image3D velocities;
layout(set = 0, binding = 3, rgba32f) uniform restrict readonly image3D extrapolated_velocitites;

const uint CELL_INACTIVE = 0;
const uint CELL_AIR = 1;
const uint CELL_WATER = 2;
const uint CELL_SOLID = 3;


uint oldCellAt(ivec3 pos){
    return imageLoad(cell_types, pos).x;
}

uint newCellAt(ivec3 pos){
    return imageLoad(new_cell_types, pos).x;
}

bool isWater(uint a){
    return (a == CELL_WATER);
}
bool isActive(uint a){
    return (a != CELL_INACTIVE);
}

vec3 getExtrapolatedVelocity(ivec3 i){
    return imageLoad(extrapolated_velocitites, i).xyz;
}


const int VELOCITY_DO_NOTHING = 0;
const int VELOCITY_RESET = 1;
const int VELOCITY_EXTRAPOLATE = 2;
int getNewVelocityState(bool was_active, bool is_active, ivec3 i){
    bool vel_was_active = was_active || isActive(oldCellAt(i));
    bool vel_is_active  =  is_active || isActive(newCellAt(i));
    if (vel_was_active){
        if (vel_is_active){
            return VELOCITY_DO_NOTHING;
        }else{
            return VELOCITY_RESET;
        }
    }else{
        if (vel_is_active){
            return VELOCITY_EXTRAPOLATE;
        }else{
            return VELOCITY_DO_NOTHING;
        }
    }
}

float getNewVelocityComponent(vec3 base_velocity, vec3 extrapolated_velocity, bool was_active, bool is_active, ivec3 i, int comp){
    ivec3 move = ivec3(0, 0, 0);
    move[comp] = -1;
    
    int vel_state = getNewVelocityState(was_active, is_active, i + move);
    if (vel_state == VELOCITY_DO_NOTHING) return base_velocity[comp];
    if (vel_state == VELOCITY_RESET) return 0;
    return extrapolated_velocity[comp];
}

vec3 getNewVelocity(ivec3 i){
    bool local_was_active = isActive(oldCellAt(i));
    bool local_is_active  = isActive(newCellAt(i));

    vec3 base_vel = imageLoad(velocities, i).xyz;
    vec3 extrapolated_vel = getExtrapolatedVelocity(i);

    return vec3(
        getNewVelocityComponent(base_vel, extrapolated_vel, local_was_active, local_is_active, i, 0),
        getNewVelocityComponent(base_vel, extrapolated_vel, local_was_active, local_is_active, i, 1),
        getNewVelocityComponent(base_vel, extrapolated_vel, local_was_active, local_is_active, i, 2)
    );
}

void main(){
    ivec3 i = ivec3(gl_GlobalInvocationID.xyz);
    imageStore(velocities, i, vec4(getNewVelocity(i), 0.0));        
}

